########################################
06-18-20
########################################
To-Do:
-Understand inputs for recurrent connectivity maps
	-Which groups are recurrent neurons?



########################################
06-17-20
########################################

To-Do:
-Look into plotallinputmaps in simdat.py
	:Gives connectivity plot of pre/post synaptic neurons
	-Make similar function to plot recurrent connectivity maps with Haroon
-Understand inputs for recurrent connectivity maps

Looking at plotallinputmaps on data:
bash
./myrun 8 sim.json (dur=2000)
#Total runtime 7323.42 s
>>> exit()
(Still in bash)
python -i simdat.py backupcfg/20june12_A_sim.json
drfmap = plotallinputmaps(pdf, pdf.time[0], dstartidx['EMUP'] + 0, 'EMUP', dnumc, dstartidx, dendidx, asweight=True)
savefig('gif/20june17_e1.png')
##File did not save


########################################
06-16-20
########################################

To-Do:
-Look into plotallinputmaps in simdat.py
	:Gives connectivity plot of pre/post synaptic neurons
	*DONE
	-Make similar function to plot recurrent connectivity maps with Haroon
-Look into sam's notes on his use of the function plotallinputmaps
	May 28, 2020 - May 29, 2020
	*DONE

#####Code for plotallinputmaps#####


def plotallinputmaps (pdf, t, postid, poty, dnumc, dstartidx, dendidx, lprety=['EV1DNW', 'EV1DN', 'EV1DNE', 'EV1DW', 'EV1','EV1DE','EV1DSW', 'EV1DS', 'EV1DSE'], asweight=False, cmap='jet',dmap=None):
  if dmap is None:
    drfmap = getallinputmaps(pdf, t, postid, poty, dnumc, dstartidx, dendidx, lprety, asweight=asweight)
  else:
    drfmap = dmap
  vmin,vmax = 1e9,-1e9
  for prety in lprety:
    vmin = min(vmin, np.amin(drfmap[prety]))
    vmax = max(vmax, np.amax(drfmap[prety]))    
  for tdx,prety in enumerate(lprety):
    subplot(3,3,tdx+1)
    imshow(drfmap[prety],cmap=cmap,origin='upper',vmin=vmin,vmax=vmax);
    title(prety+'->'+poty+str(postid));
    colorbar()
  return drfmap

####Inputs####
Function Inputs - Calling Input
pdf - pdf
t - pdf.time[0]
postid - dstartidx['EMUP'] + 0
poty - 'EMUP'
dnumc -  dnumc
dstartidx - dstartidx
dendidx - dendidx
lprety - lprety


####Notes####
drfmap = Output
lprety is a list of "EV1" parts, what is this significance? I think its neural groups being plotted. Looks like 9x9 grid, with compass directions (EV1 center)
	This makes prety (pre-ty?) the content of the list
vmin, vmax = constant min, max of the array drfmap at each pre-ty (unless 1e9,-1e9 is better?)
tdx = Counter for lprety list enumerated


####Questions####
√1. What is the point of the first if statement, dmap is set to None in the inputs?
√1a. Also, what is dmap?
	The if statement is used to avoid recomputation of dmap if it already exists. If it doesn't exist, it calls the function to compute it.

√2. What does postid mean (in reference to getallinputmaps function)?
	"  # gets all input maps onto postid "
	See number 5.
√3. Why 1e9,-1e9 for vmin,vmax?
	Sets the range form imshow to show range of synapses

√4. Does the tdx counter start at 1? (Internet says yes) If so, why start the subplot at 1+1?
	Looping tdx starts at 0 (see explination of enumerate below), but subplot counter starts at 1 in upper left corner.
√5. What are poty and postid? (title function)
	Poty is a "tag" to pass other values
		drfmap = plotallinputmaps(pdf, pdf.time[0], dstartidx[‘EMUP’] + 0, ‘EMUP’, dnumc, dstartidx, dendidx, lprety)
	Above is how function plotallinputmaps is called, EMUP is passed as poty.
	
	Postid used throughout script, seems to be the id of the post synaptic neuron when observing topological inputs.
		postid = dstartidx[‘EMUP’] + 0,
	where dstartidx['EMUP'] is the starting id of the population neurons belonging to 'EMUP.' Many neurons make synases onto single postsynaptic neuron, we see how a single neuron receives input from all different populations of neurons.


#######Explination of enumerate function#######
my_list = ['apple', 'banana', 'grapes', 'pear']
for c, value in enumerate(my_list, 1):
    print(c, value)

# Output:
# 1 apple
# 2 banana
# 3 grapes
# 4 pear

#####Sam's notes#####
Looks like sam is plotting and saving the files of e0 to e9 (data from 20may27_B1_falcor_sim.json). Does not explain much on how the function runs.

drfmap = plotallinputmaps(pdf, pdf.time[0], dstartidx[‘EMUP’] + 0, ‘EMUP’, dnumc, dstartidx, dendidx, lprety)

########################################
06-15-20
########################################
Working on X2Go vpn connection

Need to clone repository (https://github.com/NathanKlineInstitute/SMARTAgent.git) onto workspace
Need to learn GitHub terminal commands to understand how to do this

Motion of paddle seems to be after an average three null inputs after a motion input. Opposite motion input reverses direction faster. 

If motion is total 100 pixels, it seems 25~30 pixels after input motions, then 45~50, 15, 10 pixels after null inputs.

Sam wants to talk about motion with me and Haroon.
	Is there a way for system to measure what each input does, through experimenting itself?
	Will help transition network to other games.


To-Do:
-Get X2GO to run simulation
	*DONE
-Learn Github
	*DONE. Here is cheatsheet: https://gist.github.com/cferdinandi/ef665330286fd5d7127d
- Talk to Haroon about keeping paddle in middle
	-Count up/down paddle actions
	-Count ball actions to cross board
		*Working on excel sheet to count these
	**DONE. Ball_action_avg=36, Padd_action_avg=10
	-Work on paddle momentum 
		*Github post was responded to
		**It seems every action (up/down) takes multiple frames to be completed. I did up/down action (2/5) followed by no action (0) to see how many frames each input takes, and it seems to be three additional inputs. So it takes four 0 inputs to stop motion.
		**Completed on excel.
-Look into plotallinputmaps in simdat.py
	:Gives connectivity plot of pre/post synaptic neurons
	-Make similar function to plot recurrent connectivity maps with Haroon


########################################
06-12-20
########################################

Paddle seems to have momentum in all pong versions
Frameskip seems to make it harder to control paddle, as if we lose opportunity to move the paddle by skipping frames

Opened issue on GitHub to ask momentum question: 
https://github.com/openai/gym/issues/1954

If all else fails, I can make our own environment for pong:
https://github.com/openai/gym/blob/master/docs/creating-environments.md

On vpn "ssh davidd@10.76.253.155"

########################################
##Different versions of pong
########################################
https://github.com/openai/gym/blob/master/gym/envs/__init__.py

EnvSpec(Pong-v0), EnvSpec(Pong-v4) 
EnvSpec(PongDeterministic-v0), EnvSpec(PongDeterministic-v4)
EnvSpec(PongNoFrameskip-v0), EnvSpec(PongNoFrameskip-v4)
EnvSpec(Pong-ram-v0), EnvSpec(Pong-ram-v4)
EnvSpec(Pong-ramDeterministic-v0), EnvSpec(Pong-ramDeterministic-v4)
EnvSpec(Pong-ramNoFrameskip-v0), EnvSpec(Pong-ramNoFrameskip-v4)

register(
            id='{}-v0'.format(name),
            entry_point='gym.envs.atari:AtariEnv',
            kwargs={'game': game, 'obs_type': obs_type, 'repeat_action_probability': 0.25},
            max_episode_steps=10000,
            nondeterministic=nondeterministic,
        )
        register(
            id='{}-v4'.format(name),
            entry_point='gym.envs.atari:AtariEnv',
            kwargs={'game': game, 'obs_type': obs_type},
            max_episode_steps=100000,
            nondeterministic=nondeterministic,
        )
        # Standard Deterministic (as in the original DeepMind paper)
        if game == 'space_invaders':
            frameskip = 3
        else:
            frameskip = 4
        # Use a deterministic frame skip.
        register(
            id='{}Deterministic-v0'.format(name),
            entry_point='gym.envs.atari:AtariEnv',
            kwargs={'game': game, 'obs_type': obs_type, 'frameskip': frameskip, 'repeat_action_probability': 0.25},
            max_episode_steps=100000,
            nondeterministic=nondeterministic,
        )
        register(
            id='{}Deterministic-v4'.format(name),
            entry_point='gym.envs.atari:AtariEnv',
            kwargs={'game': game, 'obs_type': obs_type, 'frameskip': frameskip},
            max_episode_steps=100000,
            nondeterministic=nondeterministic,
        )
        register(
            id='{}NoFrameskip-v0'.format(name),
            entry_point='gym.envs.atari:AtariEnv',
            kwargs={'game': game, 'obs_type': obs_type, 'frameskip': 1, 'repeat_action_probability': 0.25}, # A frameskip of 1 means we get every frame
            max_episode_steps=frameskip * 100000,
            nondeterministic=nondeterministic,
        )
        # No frameskip. (Atari has no entropy source, so these are
        # deterministic environments.)
        register(
            id='{}NoFrameskip-v4'.format(name),
            entry_point='gym.envs.atari:AtariEnv',
            kwargs={'game': game, 'obs_type': obs_type, 'frameskip': 1}, # A frameskip of 1 means we get every frame
            max_episode_steps=frameskip * 100000,
            nondeterministic=nondeterministic,

########################################
##Running controlled pong
########################################
https://github.com/openai/gym/blob/7006c7a182a991b9409c206c56abc121eaffafb5/gym/envs/atari/atari_env.py


import gym; env = gym.make('PongNoFrameskip-v4’); env.reset()
##CHANGE caction to number 1, 3, 4 to move paddle, and repeat this command
observation, reward, done, info = env.step(caction); env.render()


ACTION_MEANING = {
    0: "NOOP",
    1: "FIRE",
    2: "UP",
    3: "RIGHT",
    4: "LEFT",
    5: "DOWN",
    6: "UPRIGHT",
    7: "UPLEFT",
    8: "DOWNRIGHT",
    9: "DOWNLEFT",
    10: "UPFIRE",
    11: "RIGHTFIRE",
    12: "LEFTFIRE",
    13: "DOWNFIRE",
    14: "UPRIGHTFIRE",
    15: "UPLEFTFIRE",
    16: "DOWNRIGHTFIRE",
    17: "DOWNLEFTFIRE",
}

########################################
##PRIOR NOTES
########################################

TO RUN SIM (at 2 cores)
./myrun 2 sim.jsons
mpiexec -n 2 nrniv -python -mpi sim.py

simdat.py is used to load output data from a simulation you ran. so to create that final weight output file you'd first run the simulation (which saves the data), then python -i simdat.py backupcfg/yoursimfilename.json to load the data. then this command pdfs = pdf[pdf.time==np.amax(pdf.time)]; D = pdf2weightsdict(pdfs); pickle.dump(D, open('data/'+simstr+'synWeights_final.pkl','wb'))  will save the final weights to a new output file. then you'd specify that new file in sim.json ... some of that could be automated

and when you specify that new file, it will be for the ResumeSimFromFile field

yeah, or can use multistepsim.py
which does most of that for you
python multistepSim.py sim.json 12 10 multirun
so that will run sim.json with 12 cores 10X loading weights from last run into next run sequentially
i don't always use it so i'd have a chance to look at output before starting next one...